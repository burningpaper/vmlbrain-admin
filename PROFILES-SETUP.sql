-- People Profiles schema and embeddings setup
-- Run this in your Supabase SQL editor

-- 1) Profiles table
create table if not exists public.profiles (
  id bigint generated by default as identity primary key,
  slug text not null unique,
  first_name text not null,
  last_name text not null,
  job_title text not null,
  description_html text not null,
  clients text[] default '{}'::text[],
  photo_url text,
  email text not null,
  status text not null default 'approved' check (status in ('approved','draft')),
  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

-- 2) Embeddings table for profiles
-- Ensure the pgvector extension is enabled:
-- create extension if not exists vector;
create table if not exists public.profile_embeddings (
  id bigint generated by default as identity primary key,
  profile_id bigint not null references public.profiles(id) on delete cascade,
  profile_slug text not null,
  chunk_index int not null,
  content text not null,
  embedding vector(1536) not null
);

-- 3) Useful index for similarity search (optional but recommended)
-- Using ivfflat requires ANALYZE and tuning; start with a simple L2 index if desired
-- create index on public.profile_embeddings using ivfflat (embedding vector_l2_ops) with (lists = 100);
-- Or a standard btree on slug for quick grouping
create index if not exists profile_embeddings_slug_idx on public.profile_embeddings (profile_slug);

-- 4) RPC function to match profile embeddings (similar to match_policy_embeddings)
create or replace function public.match_profile_embeddings (
  query_embedding vector(1536),
  match_threshold float,
  match_count int
) returns table (
  id bigint,
  profile_slug text,
  content text,
  chunk_index int,
  similarity float
)
language plpgsql
as $$
begin
  return query
  select
    pe.id,
    pe.profile_slug,
    pe.content,
    pe.chunk_index,
    1 - (pe.embedding <-> query_embedding) as similarity
  from public.profile_embeddings pe
  where 1 - (pe.embedding <-> query_embedding) >= match_threshold
  order by pe.embedding <-> query_embedding
  limit match_count;
end;
$$;

-- 5) RLS (adjust to your project needs)
alter table public.profiles enable row level security;
alter table public.profile_embeddings enable row level security;

-- Public read (optional - mirror policies exposure)
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'profiles' and policyname = 'Public read approved profiles'
  ) then
    create policy "Public read approved profiles"
      on public.profiles for select
      using (status = 'approved');
  end if;

  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'profile_embeddings' and policyname = 'Public read profile embeddings'
  ) then
    create policy "Public read profile embeddings"
      on public.profile_embeddings for select
      using (true);
  end if;
end $$;

-- 6) Helper view for display names (optional)
create or replace view public.profile_meta as
select
  slug,
  (first_name || ' ' || last_name) as full_name,
  job_title
from public.profiles;
